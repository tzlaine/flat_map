%%!TEX root = std.tex
\setcounter{chapter}{23}
\rSec0[containers]{Containers library}

\rSec1[containers.general]{General}

\pnum
This Clause describes components that \Cpp{} programs may use to
organize collections of information.

\pnum
The following subclauses describe
container requirements,
and components for
sequence containers and
associative containers,
as summarized in
\tref{containers.summary}.

\begin{libsumtab}{Containers library summary}{containers.summary}
\ref{container.requirements} & Requirements                     &                           \\ \rowsep
\ref{sequences}              & Sequence containers              &
  \tcode{<array>}, \tcode{<deque>}, \tcode{<forward_list>},
  \tcode{<list>}, \tcode{<vector>} \\ \rowsep
\ref{associative}            & Associative containers           &
  \tcode{<map>}, \tcode{<set>}     \\ \rowsep
\ref{unord}                  & Unordered associative containers &
  \tcode{<unordered_map>}, \tcode{<unordered_set>}    \\ \rowsep
\ref{container.adaptors}     & Container adaptors               &
  \tcode{<queue>}, \tcode{<stack>}, \tcode{<flat_map>}\added{, \tcode{<flat_set>}}     \\ \rowsep
\ref{views}                  & Views                            & \tcode{<span>} \\
\end{libsumtab}


\setcounter{section}{2}
\setcounter{subsection}{2}

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\rSec2[sequence.reqmts]{Sequence containers}

\pnum
A sequence container organizes a finite set of objects, all of the same type, into a strictly
linear arrangement. The library provides four basic kinds of sequence containers:
\tcode{vector}, \tcode{forward_list}, \tcode{list}, and \tcode{deque}. In addition,
\tcode{array} is provided as a sequence container which provides limited sequence operations
because it has a fixed number of elements. The library also provides container
adaptors that make it easy to construct abstract data types, such
as \tcode{stack}s, \tcode{queue}s, \tcode{flat_map}s, \removed{or }
\tcode{flat_multimap}s\added{, \tcode{flat_set}s, or \tcode{flat_multiset}s}
out of the basic sequence container kinds (or out of other kinds of sequence
containers).

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\setcounter{subsection}{5}
\rSec2[associative.reqmts]{Associative containers}

\pnum
Associative containers provide fast retrieval of data based on keys.
The library provides four basic kinds of associative containers:
\tcode{set},
\tcode{multiset},
\tcode{map}
and
\tcode{multimap}. The library also provides container adaptors that
make it easy to construct abstract data types, such as \tcode{flat_map}s\changed{ or}{,}
\tcode{flat_multimap}s\added{, \tcode{flat_set}s, or \tcode{flat_multiset}s,} out of
the basic sequence container kinds (or out of other program-defined sequence
containers).

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\setcounter{chapter}{24}
\setcounter{section}{5}
\rSec1[container.adaptors]{Container adaptors}

\rSec2[container.adaptors.general]{In general}

\pnum
The headers \tcode{<queue>}, \tcode{<stack>}\changed{ and}{,}
\tcode{<flat_map>}\added{, and \tcode{<flat_set>}} define the container adaptors
\tcode{queue}, \tcode{priority_queue}, \tcode{stack}\changed{ and}{,}
\tcode{flat_map}\added{, and \tcode{flat_set}}, respectively.

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\setcounter{subsection}{3}
\begin{addedblock}
\rSec2[flatset.syn]{Header \tcode{<flat_set>} synopsis}%
\indexhdr{flatset}%

\begin{codeblock}
#include <initializer_list>

namespace std {
  // \ref{flatset}, class template \tcode{flat_set}
  template<class Key, class Compare = less<Key>, class KeyContainer = vector<Key>>
    class flat_set;

  template<class Key, class Compare, class KeyContainer, class Predicate>
    size_t erase_if(flat_set<Key, Compare, KeyContainer>& c, Predicate pred);

  template<class Key, class Compare, class KeyContainer>
    struct uses_allocator<flat_set<Key, Compare, KeyContainer>, Allocator>;

  // \ref{flatmultiset}, class template \tcode{flat_multiset}
  template<class Key, class Compare = less<Key>, class KeyContainer = vector<Key>>
    class flat_multiset;

  template<class Key, class Compare, class KeyContainer, class Predicate>
    size_t erase_if(flat_multiset<Key, Compare, KeyContainer>& c, Predicate pred);

  template<class Key, class Compare, class KeyContainer>
    struct uses_allocator<flat_multiset<Key, Compare, KeyContainer>, Allocator>;
}
\end{codeblock}
\end{addedblock}

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

\begin{addedblock}
\rSec2[flatset]{Class template \tcode{flat_set}}
\rSec3[flatset.overview]{Overview}

\pnum
\indexlibrary{\idxcode{flatset}}%
A \tcode{flat_set} is a container adaptor that provides an associative
container interface that supports unique keys (i.e., contains at most one of
each key value) and provides for fast retrieval of the keys
themselves. \tcode{flat_set} supports iterators that model
the \libconcept{random_access_iterator} concept
([iterator.concept.random.access]).

\pnum
A \tcode{flat_set} satisfies all of the requirements for a container
([container.reqmts]) and for a reversible container ([container.rev.reqmts]),
plus the optional container requirements ([container.opt.reqmts]).  \tcode{flat_set}
satisfies the requirements of an associative container ([associative.reqmts]), except that:
\begin{itemize}
\item it does not meet the requirements related to node handles ([container.node.overview]),
\item it does not meet the requirements related to iterator invalidation, and
\item the time complexity of the operations that insert or erase a single
element from the set is linear, including the ones that take an insertion
position iterator.
\end{itemize}
\begin{note}A \tcode{flat_set} does not meet the additional requirements of an
allocator-aware container, as described in ([container.alloc.reqmts]).\end{note}

\pnum
A \tcode{flat_set} also provides most operations described
in ([associative.reqmts]) for unique keys.  This means that a
\tcode{flat_set} supports the \tcode{a_uniq} operations
in ([associative.reqmts]), but not the \tcode{a_eq} operations.  For a
\tcode{flat_set<Key>} both the \tcode{key_type} and \tcode{mapped_type} are
\tcode{Key}.

\pnum
Descriptions are provided here only for operations on \tcode{flat_set} that
are not described in one of those sets of requirements or for operations where
there is additional semantic information.

\pnum
Any sequence container ([sequence.reqmts]) supporting \oldconcept{RandomAccessIterator}
can be used to instantiate \tcode{flat_set}. In particular, \tcode{vector}
([vector]) and \tcode{deque} ([deque]) can be
used.  \begin{note}\tcode{vector<bool>} is not a sequence container.\end{note}

\pnum
The program is ill-formed if \tcode{Key} is not the same type
as \tcode{KeyContainer::value_type}.

\pnum
The effect of calling a constructor that takes a \tcode{sorted_unique_t}
argument with a range that is not sorted with respect to \tcode{compare}, or
that contains equal elements, is undefined.

\rSec3[flatset.defn]{Definition}

\begin{codeblock}
namespace std {
  template <class Key, class Compare = less<Key>, class KeyContainer = vector<Key>>
  class flat_set {
  public:
    // types
    using key_type                  = Key;
    using key_compare               = Compare;
    using value_type                = Key;
    using value_compare             = Compare;
    using reference                 = value_type&;
    using const_reference           = const value_type&;
    using size_type                 = size_t;
    using difference_type           = ptrdiff_t;
    using iterator                  = @\impdefx{type of \tcode{flat_set::iterator}}@; // see 24.2
    using const_iterator            = @\impdefx{type of \tcode{flat_set::const_iterator}}@; // see 24.2
    using reverse_iterator          = std::reverse_iterator<iterator>;
    using const_reverse_iterator    = std::reverse_iterator<const_iterator>;
    using container_type            = KeyContainer;

    // \ref{flatset.cons}, construct/copy/destroy
    flat_set() : flat_set(key_compare()) { }

    explicit flat_set(container_type cont);
    template <class Allocator>
      flat_set(const container_type& cont, const Allocator& a);
    explicit flat_set(initializer_list<value_type> il)
      : flat_set(il.begin(), il.end(), key_compare()) { }
    flat_set(initializer_list<value_type> il, const key_compare& comp)
      : flat_set(il.begin(), il.end(), comp) { }
    template <class Allocator>
      flat_set(initializer_list<value_type> il, const Allocator& a);
    template <class Allocator>
      flat_set(initializer_list<value_type> il, const key_compare& comp,
               const Allocator& a);

    flat_set(sorted_unique_t, container_type cont)
      : c(std::move(cont)), compare(key_compare()) { }
    template <class Allocator>
      flat_set(sorted_unique_t s, const container_type& cont, const Allocator& a);
    flat_set(sorted_unique_t s, initializer_list<value_type> il)
      : flat_set(s, il.begin(), il.end(), key_compare()) { }
    flat_set(sorted_unique_t s, initializer_list<value_type> il,
             const key_compare& comp)
      : flat_set(s, il.begin(), il.end(), comp) { }
    template <class Allocator>
      flat_set(sorted_unique_t s, initializer_list<value_type> il,
               const Allocator& a);
    template<class Allocator>
      flat_set(sorted_unique_t s, initializer_list<value_type> il,
               const key_compare& comp, const Allocator& a);

    explicit flat_set(const key_compare& comp)
      : c(), compare(comp) { }
    template <class Allocator>
      flat_set(const key_compare& comp, const Allocator&);
    template <class Allocator>
      explicit flat_set(const Allocator& a);

    template <class InputIterator>
      flat_set(InputIterator first, InputIterator last,
               const key_compare& comp = key_compare())
        : c(), compare(comp)
        { insert(first, last); }
    template <class InputIterator, class Allocator>
      flat_set(InputIterator first, InputIterator last,
               const key_compare& comp, const Allocator&);
    template <class InputIterator, class Allocator>
      flat_set(InputIterator first, InputIterator last, const Allocator& a);

    template<@\placeholder{container-compatible-range}@<value_type> R>
      flat_set(from_range_t, const R& range)
        : flat_set(std::forward<R>(range), key_compare()) { }
    template<@\placeholder{container-compatible-range}@<value_type> R, class Allocator>
      flat_set(from_range_t, const R& range, const Allocator& a);
    template<@\placeholder{container-compatible-range}@<value_type> R>
       flat_set(from_range_t, const R& range, const key_compare& comp)
         : flat_set(comp)
         { insert_range(std::forward<R>(range)); }
    template<@\placeholder{container-compatible-range}@<value_type> R, class Allocator>
       flat_set(from_range_t, const R& range, const key_compare& comp,
                const Allocator& a);

    template <class InputIterator>
      flat_set(sorted_unique_t, InputIterator first, InputIterator last,
               const key_compare& comp = key_compare())
        : c(first, last), compare(comp) { }
    template <class InputIterator, class Allocator>
      flat_set(sorted_unique_t, InputIterator first, InputIterator last,
               const key_compare& comp, const Allocator&);
    template <class InputIterator, class Allocator>
      flat_set(sorted_unique_t s, InputIterator first, InputIterator last,
               const Allocator& a);

    flat_set(initializer_list<key_type>&& il,
             const key_compare& comp = key_compare())
        : flat_set(il, comp) { }
    template <class Allocator>
      flat_set(initializer_list<key_type>&& il,
               const key_compare& comp, const Allocator& a);
    template <class Allocator>
      flat_set(initializer_list<key_type>&& il, const Allocator& a);

    flat_set(sorted_unique_t s, initializer_list<key_type>&& il,
             const key_compare& comp = key_compare()) 
        : flat_set(s, il, comp) { }
    template <class Allocator>
      flat_set(sorted_unique_t s, initializer_list<key_type>&& il,
               const key_compare& comp, const Allocator& a);
    template <class Allocator>
      flat_set(sorted_unique_t s, initializer_list<key_type>&& il,
               const Allocator& a);

    flat_set& operator=(initializer_list<key_type>);

    // iterators
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;

    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // \ref{flatset.modifiers}, modifiers
    template <class... Args> pair<iterator, bool> emplace(Args&&... args);
    template <class... Args>
      iterator emplace_hint(const_iterator position, Args&&... args);

    pair<iterator, bool> insert(const value_type& x)
      { return emplace(x); }
    pair<iterator, bool> insert(value_type&& x)
      { return emplace(std::move(x)); }
    template<class K> pair<iterator, bool> insert(K&& x);
    iterator insert(const_iterator position, const value_type& x)
      { return emplace_hint(position, x); }
    iterator insert(const_iterator position, value_type&& x)
      { return emplace_hint(position, std::move(x)); }
    template<class K> iterator insert(const_iterator hint, K&& x);

    template <class InputIterator>
      void insert(InputIterator first, InputIterator last);
    template <class InputIterator>
      void insert(sorted_unique_t, InputIterator first, InputIterator last);
    template<@\placeholder{container-compatible-range}@<value_type> R>
      void insert_range(const R& range)
        { insert(ranges::begin(range), ranges::end(range)); }

    void insert(initializer_list<key_type> il)
      { insert(il.begin(), il.end()); }
    void insert(sorted_unique_t s, initializer_list<key_type> il)
      { insert(s, il.begin(), il.end()); }

    container_type extract() &&;
    void replace(container_type&&);

    iterator erase(iterator position);
    iterator erase(const_iterator position);
    size_type erase(const key_type& x);
    template<class K> size_type erase(K&& x);
    iterator erase(const_iterator first, const_iterator last);

    void swap(flat_set& fs) noexcept;
    void clear() noexcept;

    // observers
    key_compare key_comp() const;
    value_compare value_comp() const;

    // set operations
    iterator find(const key_type& x);
    const_iterator find(const key_type& x) const;
    template <class K> iterator find(const K& x);
    template <class K> const_iterator find(const K& x) const;

    size_type count(const key_type& x) const;
    template <class K> size_type count(const K& x) const;

    bool contains(const key_type& x) const;
    template <class K> bool contains(const K& x) const;

    iterator lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    template <class K> iterator lower_bound(const K& x);
    template <class K> const_iterator lower_bound(const K& x) const;

    iterator upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;
    template <class K> iterator upper_bound(const K& x);
    template <class K> const_iterator upper_bound(const K& x) const;

    pair<iterator, iterator> equal_range(const key_type& x);
    pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
    template <class K>
      pair<iterator, iterator> equal_range(const K& x);
    template <class K>
      pair<const_iterator, const_iterator> equal_range(const K& x) const;

    friend bool operator==(const flat_set& x, const flat_set& y);

    friend @\placeholder{synth-three-way-result}@<value_type>
    bool operator<=>(const flat_set& x, const flat_set& y);

    friend void swap(flat_set& x, flat_set& y) noexcept
      { x.swap(y); }

  private:
    container_type c;    // \expos
    key_compare compare; // \expos
  };

  template <class InputIterator, class Compare = less<@\placeholder{iter-value-type}@<InputIterator>>>
    flat_set(InputIterator, InputIterator, Compare = Compare())
      -> flat_set<@\placeholder{iter-value-type}@<InputIterator>, Compare>;

  template <class InputIterator, class Compare = less<@\placeholder{iter-value-type}@<InputIterator>>>
    flat_set(sorted_unique_t, InputIterator, InputIterator, Compare = Compare())
      -> flat_set<@\placeholder{iter-value-type}@<InputIterator>, Compare>;

  template<ranges::input_range R, class Compare = less<ranges::range_value_t<R>>,
          class Allocator = allocator<ranges::range_value_t<R>>>
    flat_set(from_range_t, const R&, Compare = Compare(), Allocator = Allocator())
      -> flat_set<ranges::range_value_t<R>, Compare, Allocator>;

   template<ranges::input_range R, class Allocator>
     flat_set(from_range_t, const R&, Allocator)
       -> flat_set<ranges::range_value_t<R>, less<ranges::range_value_t<R>>, Allocator>;

  template<class Key, class Compare = less<Key>>
    flat_set(initializer_list<Key>, Compare = Compare())
      -> flat_set<Key, Compare>;

  template<class Key, class Compare = less<Key>>
    flat_set(sorted_unique_t, initializer_list<Key>, Compare = Compare())
      -> flat_set<Key, Compare>;

  template<class Key, class Compare, class KeyContainer>
    struct uses_allocator<flat_set<Key, Compare, KeyContainer>, Allocator>
      : bool_constant<uses_allocator_v<Container>> {}
}
\end{codeblock}

\rSec3[flatset.cons]{Constructors}

\indexlibrary{\idxcode{flatset}!constructor}%
\begin{itemdecl}
flat_set(container_type cont);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{c} with \tcode{std::move(cont)}, value-initializes
\tcode{compare}, sorts the range \range{begin()}{end()} with respect to
\tcode{compare}, and finally erases the range \range{ranges::unique(*this,
compare)}{end()};

\pnum
\complexity
Linear in $N$ if \tcode{cont} is sorted with respect to \tcode{compare} and
otherwise $N \log N$, where $N$ is \tcode{cont.size()}.
\end{itemdescr}

\indexlibrary{\idxcode{flatset}!constructor}%
\begin{itemdecl}
template <class Allocator>
  flat_set(const container_type& cont, const Allocator& a);
template <class Allocator>
  flat_set(initializer_list<value_type> il, const Allocator& a);
template <class Allocator>
  flat_set(initializer_list<value_type> il, const key_compare& comp,
           const Allocator& a);
template <class Allocator>
  flat_set(sorted_unique_t s, const container_type& cont, const Allocator& a);
template <class Allocator>
  flat_set(sorted_unique_t s, initializer_list<value_type> il,
           const Allocator& a);
template<class Allocator>
  flat_set(sorted_unique_t s, initializer_list<value_type> il,
           const key_compare& comp, const Allocator& a);
template <class Allocator>
  flat_set(const key_compare& comp, const Allocator&);
template <class Allocator>
  explicit flat_set(const Allocator& a);
template <class InputIterator, class Allocator>
  flat_set(InputIterator first, InputIterator last,
           const key_compare& comp, const Allocator&);
template <class InputIterator, class Allocator>
  flat_set(InputIterator first, InputIterator last, const Allocator& a);
template<@\placeholder{container-compatible-range}@<value_type> R, class Allocator>
  flat_set(from_range_t, const R& range, const Allocator& a);
template<@\placeholder{container-compatible-range}@<value_type> R, class Allocator>
   flat_set(from_range_t, const R& range, const key_compare& comp, const Allocator& a);
template <class InputIterator, class Allocator>
  flat_set(sorted_unique_t, InputIterator first, InputIterator last,
           const key_compare& comp, const Allocator&);
template <class InputIterator, class Allocator>
  flat_set(sorted_unique_t s, InputIterator first, InputIterator last,
           const Allocator& a);
template <class Allocator>
  flat_set(initializer_list<key_type>&& il,
           const key_compare& comp, const Allocator& a);
template <class Allocator>
  flat_set(initializer_list<key_type>&& il, const Allocator& a);
template <class Allocator>
  flat_set(sorted_unique_t s, initializer_list<key_type>&& il,
           const key_compare& comp, const Allocator& a);
template <class Allocator>
  flat_set(sorted_unique_t s, initializer_list<key_type>&& il,
           const Allocator& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints \tcode{uses_allocator_v<key_container_type, Allocator>} is \tcode{true}.

\pnum
\effects Equivalent to the corresponding non-allocator constructors except that \tcode{c}
is constructed with uses-allocator construction ([allocator.uses.construction]).
\end{itemdescr}

\rSec3[flatset.modifiers]{Modifiers}

\indexlibrarymember{emplace}{flatset}%
\begin{itemdecl}
template <class... Args> pair<iterator, bool> emplace(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{is_constructible_v<key_type, Args\&\&...>} is \tcode{true}.

\pnum
\effects
Initializes an object \tcode{t} of type \tcode{key_type}
with \tcode{std::forward<Args>(args)...}; if the set already contains an
element equivalent to \tcode{t}, \tcode{*this} is unchanged.  Otherwise,
equivalent to:
\begin{codeblock}
auto it = std::lower_bound(c.begin(), c.end(), t, compare);
c.insert(it, std::move(t));
\end{codeblock}

\pnum
\returns
The \tcode{bool} component of the returned pair is \tcode{true} if and only if
the insertion took place, and the iterator component of the pair points to the
element equivalent to \tcode{t}.
\end{itemdescr}

\indexlibrarymember{insert}{flatset}%
\begin{itemdecl}
template<class K> pair<iterator, bool> insert(K&& x);
template<class K> iterator insert(const_iterator hint, K&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
The \grammarterm{qualified-id} \tcode{Compare::is_transparent} is valid and denotes
a type.  \tcode{is_constructible_v<value_type, K\&\&>} is \tcode{true}.

\pnum
\expects The conversion from \tcode{k} into \tcode{value_type} constructs an
object \tcode{u}, for which \tcode{find(k) == find(u)} is true.

\pnum
\effects
If the set already contains an element equivalent to \tcode{k}, \tcode{*this}
and \tcode{args...} are unchanged.  Otherwise, inserts a new element as if
by: \tcode{return emplace(std::forward<K>(k));}.

\pnum
\returns
The \tcode{bool} component of the returned pair is \tcode{true} if and only if
the insertion took place, and the iterator component of the pair points to the
element equivalent to \tcode{k}.
\end{itemdescr}

\indexlibrarymember{insert}{flatset}%
\begin{itemdecl}
template <class InputIterator>
  void insert(InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Adds elements to \tcode{c} as if by:
\begin{codeblock}
for (; first != last; ++first) {
  c.insert(c.end(), *first);
}
\end{codeblock}
Then, sorts the range of newly inserted elements with respect
to \tcode{compare}; merges the resulting sorted range and the sorted
range of pre-existing elements into a single sorted range; and finally erases
the range \range{ranges::unique(*this, compare)}{end()}.

\pnum
\complexity
$N$ + $M \log M$, where $N$ is \tcode{size()} before the operation and $M$
is \tcode{distance(first, last)}.
\end{itemdescr}

\indexlibrarymember{insert}{flatset}%
\begin{itemdecl}
template <class InputIterator>
  void insert(sorted_unique_t, InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum \expects
The range \range{first}{last} is sorted with respect to \tcode{compare}.

\pnum \effects Equivalent to: \tcode{insert(first, last)}.

\pnum \complexity Linear.
\end{itemdescr}

\indexlibrarymember{swap}{flatset}%
\begin{itemdecl}
void swap(flat_set& fs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum \effects Equivalent to:
\begin{codeblock}
ranges::swap(compare, fs.compare);
ranges::swap(c, fs.c);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{extract}{flatset}%
\begin{itemdecl}
container_type extract() &&;
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{std::move(c)}.

\pnum \ensures \tcode{*this} is emptied, even if the function exits via exception.
\end{itemdescr}

\indexlibrarymember{replace}{flatset}%
\begin{itemdecl}
void replace(container_type&& cont);
\end{itemdecl}

\begin{itemdescr}
\pnum \expects
The elements of \tcode{cont} are sorted with respect to \tcode{compare}.

\pnum
\effects Equivalent to:
\begin{codeblock}
c = std::move(cont);
\end{codeblock}
\end{itemdescr}

\rSec3[flatset.erasure]{Erasure}

\indexlibrarymember{erase_if}{flatset}%
\begin{itemdecl}
template<class Key, class Compare, class KeyContainer, class Predicate>
  size_t erase_if(flat_set<Key, Compare, KeyContainer>& c, Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Removes the elements for which \tcode{pred} is \tcode{true}, as if by:
\begin{codeblock}
  auto [erase_first, erase_last] = ranges::remove_if(c, pred);
  return c.erase(erase_first, erase_last);
\end{codeblock}
\end{itemdescr}

\rSec2[flatmultiset]{Class template \tcode{flat_multiset}}
\rSec3[flatmultiset.overview]{Overview}

\pnum
\indexlibrary{\idxcode{flatmultiset}}%
A \tcode{flat_multiset} is a container adaptor that provides an associative
container interface that supports equivalent keys (i.e., possibly containing
multiple copies of the same key value) and provides for fast retrieval of the
keys themselves. \tcode{flat_multiset} supports iterators that model
the \libconcept{random_access_iterator} concept
([iterator.concept.random.access]).

\pnum
A \tcode{flat_multiset} satisfies all of the requirements for a container
([container.reqmts]) and for a reversible container ([container.rev.reqmts]),
plus the optional container requirements ([container.opt.reqmts]).  \tcode{flat_multiset}
satisfies the requirements of an associative container ([associative.reqmts]), except that:
\begin{itemize}
\item it does not meet the requirements related to node handles ([container.node.overview]),
\item it does not meet the requirements related to iterator invalidation, and
\item the time complexity of the operations that insert or erase a single
element from the set is linear, including the ones that take an insertion
position iterator.
\end{itemize}
\begin{note}A \tcode{flat_multiset} does not meet the additional requirements of an
allocator-aware container, as described in ([container.alloc.reqmts]).\end{note}

\pnum
A \tcode{flat_multiset} also provides most operations described
in ([associative.reqmts]) for equal keys.  This means that a
\tcode{flat_multiset} supports the \tcode{a_eq} operations
in ([associative.reqmts]), but not the \tcode{a_uniq} operations.  For
a \tcode{flat_multiset<Key,T>} the \tcode{key_type} is \tcode{Key} and the
\tcode{value_type} is \tcode{pair<const Key,T>}.

\pnum
Descriptions are provided here only for operations on \tcode{flat_multiset}
that are not described in one of the general sections or for operations where
there is additional semantic information.

\pnum
Any sequence container ([sequence.reqmts]) supporting \oldconcept{RandomAccessIterator}
can be used to instantiate \tcode{flat_multiset}. In
particular, \tcode{vector} ([vector]) and \tcode{deque} ([deque]) can be
used.  \begin{note}\tcode{vector<bool>} is not a sequence container.\end{note}

\pnum
The program is ill-formed if \tcode{Key} is not the same type
as \tcode{KeyContainer::value_type}.

\pnum
The effect of calling a constructor that takes a \tcode{sorted_equivalent_t}
argument with a container or containers that are not sorted with respect
to \tcode{value_compare} is undefined.

\rSec3[flatmultiset.defn]{Definition}

\begin{codeblock}
template <class Key, class Compare = less<Key>, class KeyContainer = vector<Key>>
class flat_multiset {
  public:
    // types
    using key_type                  = Key;
    using key_compare               = Compare;
    using value_type                = Key;
    using value_compare             = Compare;
    using reference                 = value_type&;
    using const_reference           = const value_type&;
    using size_type                 = size_t;
    using difference_type           = ptrdiff_t;
    using iterator                  = @\impdefx{type of \tcode{flat_multiset::iterator}}@; // see 24.2
    using const_iterator            = @\impdefx{type of \tcode{flat_multiset::const_iterator}}@; // see 24.2
    using reverse_iterator          = std::reverse_iterator<iterator>;
    using const_reverse_iterator    = std::reverse_iterator<const_iterator>;
    using container_type            = KeyContainer;

    // \ref{flatmultiset.cons}, construct/copy/destroy
    flat_multiset() : flat_multiset(key_compare()) { }

    explicit flat_multiset(container_type cont);
    template <class Allocator>
      flat_multiset(const container_type& cont, const Allocator& a);
    explicit flat_multiset(initializer_list<value_type> il)
      : flat_multiset(il.begin(), il.end(), key_compare()) { }
    flat_multiset(initializer_list<value_type> il, const key_compare& comp)
      : flat_multiset(il.begin(), il.end(), comp) { }
    template <class Allocator>
      flat_multiset(initializer_list<value_type> il, const Allocator& a);
    flat_multiset(initializer_list<value_type> il, const key_compare& comp,
                  const Allocator& a);

    flat_multiset(sorted_equivalent_t, container_type cont)
      : c(std::move(cont)), compare(key_compare()) { }
    template <class Allocator>
      flat_multiset(sorted_equivalent_t, const container_type&, const Allocator&);
    flat_multiset(sorted_equivalent_t s, initializer_list<value_type> il)
      : flat_multiset(s, il.begin(), il.end(), key_compare()) { }

    flat_multiset(sorted_equivalent_t s, initializer_list<value_type> il,
                  const key_compare& comp)
      : flat_multiset(s, il.begin(), il.end(), comp) { }
    template <class Allocator>
      flat_multiset(sorted_equivalent_t s, initializer_list<value_type> il,
                    const Allocator& a);
    template <class Allocator>
      flat_multiset(sorted_equivalent_t s, initializer_list<value_type> il,
                    const key_compare& comp, const Allocator& a);

    explicit flat_multiset(const key_compare& comp)
      : c(), compare(comp) { }
    template <class Allocator>
      flat_multiset(const key_compare& comp, const Allocator&);
    template <class Allocator>
      explicit flat_multiset(const Allocator& a);

    template <class InputIterator>
      flat_multiset(InputIterator first, InputIterator last,
                    const key_compare& comp = key_compare())
        : c(), compare(comp)
        { insert(first, last); }
    template <class InputIterator, class Allocator>
      flat_multiset(InputIterator first, InputIterator last,
                    const key_compare& comp, const Allocator&);
    template <class InputIterator, class Allocator>
      flat_multiset(InputIterator first, InputIterator last,
                    const Allocator& a);

    template<@\placeholder{container-compatible-range}@<value_type> R>
      flat_multiset(from_range_t, const R& range)
        : flat_multiset(std::forward<R>(range), key_compare()) { }
    template<@\placeholder{container-compatible-range}@<value_type> R, class Allocator>
      flat_multiset(from_range_t, const R& range, const Allocator& a);
    template<@\placeholder{container-compatible-range}@<value_type> R>
      flat_multiset(from_range_t, const R& range, const key_compare& comp)
        : flat_multiset(comp)
        { insert_range(std::forward<R>(range)); }
    template<@\placeholder{container-compatible-range}@<value_type> R, class Allocator>
      flat_multiset(from_range_t, const R& range, const key_compare& comp,
                    const Allocator& a);

    template <class InputIterator>
      flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
                    const key_compare& comp = key_compare())
        : c(first, last), compare(comp) { }
    template <class InputIterator, class Allocator>
      flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
                    const key_compare& comp, const Allocator&);
    template <class InputIterator, class Allocator>
      flat_multiset(sorted_equivalent_t s, InputIterator first, InputIterator last,
                    const Allocator& a);

    flat_multiset(initializer_list<key_type>&& il,
                  const key_compare& comp = key_compare())
      : flat_multiset(il, comp) { }
    template <class Allocator>
      flat_multiset(initializer_list<key_type>&& il,
                    const key_compare& comp, const Allocator& a);
    template <class Allocator>
      flat_multiset(initializer_list<key_type>&& il, const Allocator& a);

    flat_multiset(sorted_equivalent_t s, initializer_list<key_type>&& il,
                  const key_compare& comp = key_compare())
        : flat_multiset(s, il, comp) { }
    template <class Allocator>
      flat_multiset(sorted_equivalent_t s, initializer_list<key_type>&& il,
                    const key_compare& comp, const Allocator& a);
    template <class Allocator>
      flat_multiset(sorted_equivalent_t s, initializer_list<key_type>&& il,
                    const Allocator& a);

    flat_multiset& operator=(initializer_list<key_type>);

    // iterators
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;

    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // \ref{flatmultiset.modifiers}, modifiers
    template <class... Args> iterator emplace(Args&&... args);
    template <class... Args>
      iterator emplace_hint(const_iterator position, Args&&... args);

    pair<iterator, bool> insert(const value_type& x)
      { return emplace(x); }
    pair<iterator, bool> insert(value_type&& x)
      { return emplace(std::move(x)); }
    iterator insert(const_iterator position, const value_type& x)
      { return emplace_hint(position, x); }
    iterator insert(const_iterator position, value_type&& x)
      { return emplace_hint(position, std::move(x)); }

    template <class InputIterator>
      void insert(InputIterator first, InputIterator last);
    template <class InputIterator>
      void insert(sorted_equivalent_t, InputIterator first, InputIterator last);
    template<c@\placeholder{container-compatible-range}@<value_type> R>
      void insert_range(const R& range)
        { insert(ranges::begin(range), ranges::end(range)); }

    void insert(initializer_list<key_type> il)
      { insert(il.begin(), il.end()); }
    void insert(sorted_unique_t s, initializer_list<key_type> il)
      { insert(s, il.begin(), il.end()); }

    container_type extract() &&;
    void replace(container_type&&);

    iterator erase(iterator position);
    iterator erase(const_iterator position);
    size_type erase(const key_type& x);
    template<class K> size_type erase(K&& x);
    iterator erase(const_iterator first, const_iterator last);

    void swap(flat_multiset& fms) noexcept;
    void clear() noexcept;

    // observers
    key_compare key_comp() const;
    value_compare value_comp() const;

    // set operations
    iterator find(const key_type& x);
    const_iterator find(const key_type& x) const;
    template <class K> iterator find(const K& x);
    template <class K> const_iterator find(const K& x) const;

    size_type count(const key_type& x) const;
    template <class K> size_type count(const K& x) const;

    bool contains(const key_type& x) const;
    template <class K> bool contains(const K& x) const;

    iterator lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    template <class K> iterator lower_bound(const K& x);
    template <class K> const_iterator lower_bound(const K& x) const;

    iterator upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;
    template <class K> iterator upper_bound(const K& x);
    template <class K> const_iterator upper_bound(const K& x) const;

    pair<iterator, iterator> equal_range(const key_type& x);
    pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
    template <class K>
      pair<iterator, iterator> equal_range(const K& x);
    template <class K>
      pair<const_iterator, const_iterator> equal_range(const K& x) const;

    friend bool operator==(const flat_multiset& x, const flat_multiset& y);

    friend @\placeholder{synth-three-way-result}@<value_type>
    bool operator<=>(const flat_multiset& x, const flat_multiset& y);

    friend void swap(flat_multiset& x, flat_multiset& y) noexcept
      { x.swap(y); }

  private:
    container_type c;    // \expos
    key_compare compare; // \expos
  };

  template <class InputIterator, class Compare = less<@\placeholder{iter-value-type}@<InputIterator>>>
    flat_multiset(InputIterator, InputIterator, Compare = Compare())
      -> flat_multiset<@\placeholder{iter-value-type}@<InputIterator>, @\placeholder{iter-value-type}@<InputIterator>, Compare>;

  template <class InputIterator, class Compare = less<@\placeholder{iter-value-type}@<InputIterator>>>
    flat_multiset(sorted_equivalent_t, InputIterator, InputIterator, Compare = Compare())
      -> flat_multiset<@\placeholder{iter-value-type}@<InputIterator>, @\placeholder{iter-value-type}@<InputIterator>, Compare>;

  template<ranges::input_range R, class Compare = less<ranges::range_value_t<R>>,
          class Allocator = allocator<ranges::range_value_t<R>>>
    flat_multiset(from_range_t, const R&, Compare = Compare(), Allocator = Allocator())
      -> flat_multiset<ranges::range_value_t<R>, Compare, Allocator>;

   template<ranges::input_range R, class Allocator>
     flat_multiset(from_range_t, const R&, Allocator)
       -> flat_multiset<ranges::range_value_t<R>, less<ranges::range_value_t<R>>, Allocator>;

  template<class Key, class Compare = less<Key>>
    flat_multiset(initializer_list<Key>, Compare = Compare())
      -> flat_multiset<Key, Compare>;

  template<class Key, class Compare = less<Key>>
  flat_multiset(sorted_equivalent_t, initializer_list<Key>, Compare = Compare())
      -> flat_multiset<Key, Compare>;

  template<class Key, class Compare, class KeyContainer>
    struct uses_allocator<flat_multiset<Key, Compare, KeyContainer>, Allocator>
      : bool_constant<uses_allocator_v<Container>> {}
}
\end{codeblock}

\rSec3[flatmultiset.cons]{Constructors}

\indexlibrary{\idxcode{flatmultiset}!constructor}%
\begin{itemdecl}
flat_multiset(container_type cont);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{c} with \tcode{std::move(cont)}, value-initializes
\tcode{compare}, and sorts the range \range{begin()}{end()} with respect to
\tcode{compare}.

\pnum
\complexity
Linear in $N$ if \tcode{cont} is sorted with respect to \tcode{compare} and
otherwise $N \log N$, where $N$ is \tcode{cont.size()}.
\end{itemdescr}

\indexlibrary{\idxcode{flatmultiset}!constructor}%
\begin{itemdecl}
template <class Allocator>
  flat_multiset(const container_type& cont, const Allocator& a);
template <class Allocator>
  flat_multiset(initializer_list<value_type> il, const Allocator& a);
flat_multiset(initializer_list<value_type> il, const key_compare& comp,
              const Allocator& a);
template <class Allocator>
  flat_multiset(sorted_equivalent_t, const container_type&, const Allocator&);
template <class Allocator>
  flat_multiset(sorted_equivalent_t s, initializer_list<value_type> il,
                const Allocator& a);
template <class Allocator>
  flat_multiset(sorted_equivalent_t s, initializer_list<value_type> il,
                const key_compare& comp, const Allocator& a);
template <class Allocator>
  flat_multiset(const key_compare& comp, const Allocator&);
template <class Allocator>
  explicit flat_multiset(const Allocator& a);
template <class InputIterator, class Allocator>
  flat_multiset(InputIterator first, InputIterator last,
                const key_compare& comp, const Allocator&);
template <class InputIterator, class Allocator>
  flat_multiset(InputIterator first, InputIterator last,
                const Allocator& a);
template<@\placeholder{container-compatible-range}@<value_type> R, class Allocator>
  flat_multiset(from_range_t, const R& range, const Allocator& a);
template<@\placeholder{container-compatible-range}@<value_type> R, class Allocator>
  flat_multiset(from_range_t, const R& range, const key_compare& comp,
                const Allocator& a);
template <class InputIterator, class Allocator>
  flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
                const key_compare& comp, const Allocator&);
template <class InputIterator, class Allocator>
  flat_multiset(sorted_equivalent_t s, InputIterator first, InputIterator last,
                const Allocator& a);
template <class Allocator>
  flat_multiset(initializer_list<key_type>&& il,
                const key_compare& comp, const Allocator& a);
template <class Allocator>
  flat_multiset(initializer_list<key_type>&& il, const Allocator& a);
template <class Allocator>
  flat_multiset(sorted_equivalent_t s, initializer_list<key_type>&& il,
                const key_compare& comp, const Allocator& a);
template <class Allocator>
  flat_multiset(sorted_equivalent_t s, initializer_list<key_type>&& il,
                const Allocator& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints \tcode{uses_allocator_v<key_container_type, Allocator>} is \tcode{true}.

\pnum
\effects Equivalent to the corresponding non-allocator constructors except that \tcode{c}
is constructed with uses-allocator construction ([allocator.uses.construction]).
\end{itemdescr}

\rSec3[flatmultiset.modifiers]{Modifiers}

\indexlibrarymember{emplace}{flatmultiset}%
\begin{itemdecl}
template <class... Args> iterator emplace(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum \constraints \tcode{is_constructible_v<key_type, Args\&\&...>} is \tcode{true}.

\pnum
\effects
First, initializes an object \tcode{t} of type \tcode{key_type}
with \tcode{std::forward<Args>(args)...}, then inserts \tcode{t} as if by:
\begin{codeblock}
auto it = ranges::upper_bound(c, t, compare);
c.insert(it, std::move(t));
\end{codeblock}

\pnum
\returns
An iterator that points to the inserted element.
\end{itemdescr}

\indexlibrarymember{insert}{flatmulitset}%
\begin{itemdecl}
template <class InputIterator>
  void insert(InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Adds elements to \tcode{c} as if by:
\begin{codeblock}
for (; first != last; ++first) {
  c.insert(c.end(), *first);
}
\end{codeblock}
Then, sorts the range of newly inserted elements with respect to \tcode{compare},
and merges the resulting sorted range and the sorted range of pre-existing
elements into a single sorted range.

\pnum
\complexity
$N$ + $M \log M$, where $N$ is \tcode{size()} before the operation and $M$
is \tcode{distance(first, last)}.
\end{itemdescr}

\indexlibrarymember{insert}{flatmultiset}%
\begin{itemdecl}
template <class InputIterator>
  void insert(sorted_unique_t, InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum \expects
The range \range{first}{last} is sorted with respect to \tcode{compare}.

\pnum \effects Equivalent to: \tcode{insert(first, last)}.

\pnum \complexity Linear.
\end{itemdescr}

\indexlibrarymember{swap}{flatmultiset}%
\begin{itemdecl}
void swap(flat_multiset& fms) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum \effects Equivalent to:
\begin{codeblock}
ranges::swap(compare, fms.compare);
ranges::swap(c, fms.c);
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{extract}{flatmultiset}%
\begin{itemdecl}
container_type extract() &&;
\end{itemdecl}

\begin{itemdescr}
\pnum \returns \tcode{std::move(c)}.

\pnum \ensures \tcode{*this} is emptied, even if the function exits via exception.
\end{itemdescr}

\indexlibrarymember{replace}{flatmultiset}%
\begin{itemdecl}
void replace(container_type&& cont);
\end{itemdecl}

\begin{itemdescr}
\pnum \expects
The elements of \tcode{cont} are sorted with respect to \tcode{compare}.

\pnum
\effects Equivalent to:
\begin{codeblock}
c = std::move(cont);
\end{codeblock}
\end{itemdescr}

\rSec3[flatmultiset.erasure]{Erasure}

\indexlibrarymember{erase_if}{flatmultiset}%
\begin{itemdecl}
template<class Key, class Compare, class KeyContainer, class Predicate>
  size_t erase_if(flat_multiset<Key, Compare, KeyContainer>& c, Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Removes the elements for which \tcode{pred} is \tcode{true}, as if by:
\begin{codeblock}
  auto [erase_first, erase_last] = ranges::remove_if(c, pred);
  return c.erase(erase_first, erase_last);
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}

Add to section [container.adaptors.format]:

\rSec2[container.adaptors.format]{Formatting}
\begin{addedblock}
\pnum
For each of \tcode{flat_set} and \tcode{flat_multiset} templates, the library provides
the following formatter specialization where \placeholder{set-type} is the
name of the template:

\begin{codeblock}
namespace std {
  template <class charT, formattable<charT> Key, class... U>
  struct formatter<@\placeholder{set-type}@<Key, U...>, charT>
  {
  private:
    range_formatter<Key, charT> underlying_; // \expos

  public:
    formatter();

    template <class ParseContext>
      constexpr typename ParseContext::iterator
        parse(ParseContext& ctx);

    template <class FormatContext>
      typename FormatContext::iterator
        format(const @\placeholder{set-type}@<Key, U...>& r, FormatContext& ctx) const;
  };
}
\end{codeblock}

\begin{itemdecl}
formatter();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
this->set_brackets(@\placeholder{STATICALLY-WIDEN}@<charT>("{"), @\placeholder{STATICALLY-WIDEN}@<charT>("}"));
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template <class ParseContext>
  constexpr typename ParseContext::iterator
    parse(ParseContext& ctx);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return underlying_.parse(ctx);}
\end{itemdescr}

\begin{itemdecl}
template <class FormatContext>
  typename FormatContext::iterator
    format(const @\placeholder{set-type}@<Key, U...>& r, FormatContext& ctx) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return underlying_.format(r, ctx);}
\end{itemdescr}
\end{addedblock}
